<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Entry.css</title>
  <link rel="stylesheet" href="bin/markdown.css" />
  <meta name="Keywords" content="Entry.css,中文文章,博客样式"/>
  <meta name="Description" content="Entry.css 中文文章样式解决方案，帮助你快速搭建中文博客主题。"/>
</head>
<body class="markdown">
<h1>译Javascript Test Spies, Stubs and Mocks</h1>
<p>译者言：本文是<cite>Test-Driven Javascript Development</cite>一书的作者的博文，关于他设计Javascript测试库<a href="http://sinonjs.org/">Sinon</a>时的思路和想法。

</p>
<hr>
<p>最近我在写<a href="http://cjohansen.no/en/javascript/test_driven_javascript_the_book">书</a>过程中遇到的事情就是一个叫Sinon的Javascript stubbing和mocking库（还在开发中）。一次给出三篇文章来展示API的预览。希望可以得到一些你们的想法和反馈。

</p>
<p>在这篇文章中，我们会了解库里面的核心部分：spies，stubs和mocks。我会覆盖到此库的基本想法，并且展示最为相关的API。

</p>
<h2>Sinon的目标</h2>
<p>为什么要写另一个stubbing和mocking的库呢？现在已经有了不少类似的库了，并且有部分测试库发布时就内建了stub和mocks的功能。原本我写Sinon是为了写书，在“TDD by example”这一章节里面使用它。最终这没有成为现实，但是我依旧使用它作为“使用stubbing和mocking库”的样例（相对于我们最简单、最经常遇到的手工stubbing的情况）。

</p>
<p>我对这样的一个库做了如下需求设计：

</p>
<ul>
<li><strong>独立</strong> 没有理由把stubbing和mocking功能绑定到一个指定的测试库中。虽然在某些情况下它可以被自动化，但是这样的集成也可以由独立的库来提供。</li>
<li><strong>最小化全局变量占用</strong> 在测试环境中你绝对不希望大量的全局命名污染。Stub和Mock API
必须是在同一个对象上的</li>
<li><strong>容易使用</strong> 这可能是理所应当的，但是某些我见过的mocking解决方案就需要大量额外的工具库依赖才可以运行。</li>
<li><strong>容易集成</strong> 之所以做成独立的库，就是希望最小化库，使其容易被自动集成到任何测试库中。</li>
<li><strong>CommonJS兼容</strong> 使用CommonJS模块标准，能同时工作在浏览器和Server上</li>
</ul>
<p>Sinon实现了这些需求。它是独立的，它的API都在<code>sinon</code>对象上，它拥有一个（希望是）简单的API并且提供了一系列工具来减少依赖大量的工具库。这篇文章专注于它的API，并且我会很快发布关于集成部分的文章。

</p>
<h2>现状</h2>
<p>目前，Sinon的核心（本篇文章覆盖到的）是可以工作的，但是库整体还没有完成，API本身也没有固定。我希望通过分享这些信息来降低提供反馈和建议的门槛。我不会正式发布它，知道我有了合适的文档。这篇文章以及之后的两篇是一个开始。

</p>
<p>结束聊天，直接上代码

</p>
<h2>Test spies</h2>
<p><a href="http://xunitpatterns.com/Test%20Spy.html">测试spy</a>是一个对象，它记录了自己与整个代码库中其他对象交互。当无法仅仅通过可用对象状态来决定一个测试成功与否的时候，我们可以使用测试spies，并且断言回调的执行次数、传递的参数、返回值等等。

</p>
<p>Sinon以函数的形式实现了spies，它包裹了其他函数，然后记录每次调用，包括<code>this</code>、参数、返回值和任何抛出的exception。它可以在不影响默认行为的情况监控方法，虽然在实践中你很少会直接创建spy。Stubs和mocks都是通过spy借口实现的。

</p>
<p>Spies有一些属性和有用的方法。如下是你监控jQuery的<code>ajax</code>方法的例子：

</p>
<pre><code>sinon.spy(jQuery, &quot;ajax&quot;);
jQuery.getJSON(&quot;/some/data&quot;);</code></pre>
<p>这么做不会影响<code>jQuery.ajax</code>的默认行为，但是它会包裹这个方法并记录数据。

</p>
<h3>属性</h3>
<p>如下的属性是spies暴露的，并且是如上样例对应的结果：

</p>
<ul>
<li><code>jQuery.ajax.called</code> boolean, <code>true</code></li>
<li><code>jQuery.ajax.callCount</code> number, <code>1</code></li>
<li><code>jQuery.ajax.calledOnce</code> boolean, <code>true</code></li>
<li><code>jQuery.ajax.calledTwice</code> boolean, <code>false</code></li>
<li><code>jQuery.ajax.calledThrice</code> boolean, <code>false</code></li>
</ul>
<h3>调用数据</h3>
<p>Spies在四个数组中存储了调用数据。如果你喜欢底层代码，你们你会需要他们。

</p>
<ul>
<li><code>jQuery.ajax.args</code><br/>
是spy接收到的arguments数组。为了获取到第一次调用的第一个参数，你需要这么做<code>jQuery.ajax.args[0][0]</code>，第一个0表示调用次数，第二个表示第几个参数。</li>
<li><code>jQuery.ajax.returnValues</code><br/>
是回调函数的返回结果数组。为了获得第一次调用的返回结果，你需要这么做<code>jQuery.ajax.returnValues[0]</code>。对那些没有显示返回值的调用，数组会存储<code>undefined</code>值。</li>
<li><code>jQuery.ajax.exceptions</code><br/>
是spy抛出的exception的数组。如果spy在给定的调用中不抛出exception，数组会存储<code>undefined</code>。这个数组每次调用总是包含一个实体，不管它有没有抛出它。</li>
<li><code>jQuery.ajax.thisValues</code><br/>
是包含了<code>this</code>值的数组。对每次调用，spy存储<code>this</code>值到数组中，它在测试绑定了特殊对象的函数或是使用了<code>call</code>和<code>apply</code>方法的函数调用时很有用。</li>
</ul>
<h3>方法</h3>
<p>如果你喜欢底层代码，上面的四个数组可以提供你想要的所有东西，帮助你监控调用的整个过程。如果你和我更像一些，喜欢高层封装方法来让测试用例的意图更清晰，你可能更喜欢如下提供的方法。

</p>
<ul>
<li><code>jQuery.ajax.calledWith(arg1, arg2, ...)</code><br/>
此方法传递任意数量的参数，并且只要指定的arguments被调用了一次，那么这个方法就会返回<code>true</code>。arguments列表不需要很详细 - 你可以提供第一个参数，如果任意一次调用的参数中第一个是你传递的值，你们这个方法就会返回<code>true</code>。（这解决了可选参数的情况）</li>
<li><code>jQuery.ajax.calledWithExactly(arg1, arg2, ...)</code><br/>
如果你需要知道一个函数是否接收了指定的参数，并且只有那些指定的参数，这个方法就是<code>calledWith(arg1, arg2, ...)</code>的严格版本。</li>
<li><code>jQuery.ajax.alwaysCalledWith(arg1, arg2, ...)</code><br/>
和<code>calledWith(arg1, arg2, ...)</code>几乎一样，除了它需要所有的调用都符合。</li>
<li><code>jQuery.ajax.alwaysCalledWithExactly(arg1, arg2, ...)</code><br/>
和<code>calledWith(arg1, arg2, ...)</code>类似，只是它需要所有的调用都严格相符。</li>
<li><code>returned(returnValue)</code><br/>
返回<code>true</code>，如果spy返回的值与指定的值相同。</li>
<li><code>alwaysReturned(returnValue)</code><br/>
同上，只有在符合所有调用的时候返回<code>true</code>。</li>
<li><code>threw(exceptionOrType)</code><br/>
如果没有参数被传递且如果spy任意一次调用中抛出一个exception，那么方法返回<code>true</code>。如果一个字符串被传递给它，且spy抛出一个相同类型的excption（例如<code>TypeError</code>），那么方法返回<code>true</code>。最后，如果一个exception对象被传递给它，且spy抛出的exception对象和指定的对象一致（这个不太可能被用到，因为没办法构造完全一致的对象），那么方法返回<code>true</code>。<br/>
我认为这个方法可以接收两个字符串，分别表示抛出错误的类型和message。它甚至接收一个字符串的类型和正则表达式来匹配message。你怎么认为？</li>
<li><code>alwaysThrew(...)</code><br/>
同上，只是必须全部的调用都符合。</li>
<li><code>calledOn(thisObj)</code>
如果方法被调用时的this值是指定的值，那么返回<code>true</code>。</li>
<li><code>alwaysCalledOn(...)</code>
同上，只是必须全部的调用都符合。</li>
</ul>
<p>作为补充，spies有一个特殊的方法来“解除”它们被监控的方法：

</p>
<pre><code>jQuery.ajax.restore();</code></pre>
<p>这个方法解除了包裹并且恢复了默认的方法。为了spies在测试之间泄露，所有spies都可以在测试用例<code>tearDown</code>（举个例子）的时候恢复。

</p>
<p>使用这些方法及断言可以实现可读性较好的测试：

</p>
<pre><code>&quot;test should register click events for buttons&quot;: function () {
  sinon.spy(dom, &quot;addEventHandler&quot;);
  var buttons = dom.get(&quot;div.button&quot;, this.form);

  this.feedback.setForm(this.form);

  assert(dom.addEventHandler.calledWith(buttons[0], &quot;click&quot;));
  assert(dom.addEventHandler.calledWith(buttons[1], &quot;click&quot;));
  assert(dom.addEventHandler.calledWith(buttons[2], &quot;click&quot;));
}</code></pre>
<p>这个测试使用了一些库中自带的工具。它验证了一个表单中的所有按钮都绑定了点击事件的监听。注意断言只检查了两个参数——元素和事件名，没有包含回调函数。review这个例子让我意识到我可以在这个例子中使用事件代理，但是好吧......

</p>
<p>Sinon有一些更高层的工具来使用spies，我会在下一篇文章中覆盖到它们。

</p>
<h2>Stubs</h2>
<p><a href="http://xunitpatterns.com/Test%20Stub.html">测试Stubs</a>是假的对象，它们被预先编码了行为。它们会在下面两个情况下被用到：

</p>
<ol>
<li>避免使用不方便的借口——例如避免向服务器请求数据</li>
<li>反馈给系统已知的数据，强制指定代码路径</li>
</ol>
<p>Javascript函数是“first-class”（译者言：词法作用域的概念，有人翻译成一等公民，窃以为不合适故不翻译）的，这让你花很长时间决定伪代码样例：

</p>
<pre><code>&quot;test should call event handler&quot;: function () {
  var handler = function () { handler.called = true; };
  var myElement = document.getElementsByTagName(&quot;a&quot;)[0];

  dom.addEventListener(myElement, &quot;mouseover&quot;, handler);
  dom.fireEvent(myElement, &quot;mouseover&quot;);

  assertTrue(handler.called);
}</code></pre>
<p>因为Javascript函数如此的多才多艺，大部分情况下对stubs的使用是很容易解决的。然而，在做了一段时间之后，你意识到使用一个库可以减少你的工作量，特别是stub全局接口的时候，例如之前说的<code>jQuery.ajax</code>。

</p>
<h3>创建Stub</h3>
<p>Sinon提供了一个简单的创建stub的API。调用<code>sinon.stub()</code>就可以创建stub。它返回了一个“空”函数，这个函数支持之前提到过的spy的API。这样上面的那个例子可以被写成：

</p>
<pre><code>&quot;test should call event handler&quot;: function () {
  var handler = sinon.stub();
  var myElement = document.getElementsByTagName(&quot;a&quot;)[0];

  dom.addEventListener(myElement, &quot;mouseover&quot;, handler);
  dom.fireEvent(myElement, &quot;mouseover&quot;);

  assertTrue(handler.called);
}</code></pre>
<p>代码只是变得简单了一点点，不过这是个非常简单的例子。因为它支持所有的spy的接口，我们可以检查调用次数、this、arguments以及其他。

</p>
<h3>Stubs的方法</h3>
<ul>
<li><code>returns(returnValue)</code><br/>
设置stub的返回值。</li>
<li><code>throws(exception)</code><br/>
设置stub抛出的exception，如果参数是一个字符串，则代表了抛出exception的类型。如果它是一个对象，则会把他当作一个exception抛出。如果没有提供参数，那么会在调用时抛出一个<code>Error</code>。</li>
<li><code>callsArg(index)</code><br/>
<strong>此API很可能会改变！</strong> 这个方法会导致stub立即调用并将参数传递进去。index参数表示传入参数的序号（从0开始），对应序号的参数会被当作一个回调函数。我认为这个方法的名字或者参数都不太好。欢迎给出建议。</li>
<li><code>callsArgWith(index, arg1, arg2, ...)</code><br/>
<strong>此API很可能会改变！</strong> 就像上面的方法一样，只是你可以为回调函数设置参数。和<code>callsArg</code>一样，我不确信这个方法的命名是否够好。我希望它更加直观，但是这是我能想到最好的了。</li>
</ul>
<p>对于最后两个方法只要我把它们设计的够好，它们一定会非常有用。我也想让stub可以在调用时传递“可选”的参数。我还没有想到一个合理长度的、清晰简明的命名。目前它还有明显的不足，欢迎给我提意见。

</p>
<p>所有的方法都返回stub，所以它们可以链式调用，例如：

</p>
<pre><code>sinon.stub(jQuery, &quot;each&quot;).callsArgWith(1, {}).returns({});</code></pre>
<p>上面代码创建了<code>jQuery.each</code>方法的stub。当它被调用的时候，会以<code>callsArgWith</code>方法的第二参数作为参数，并且返回一个空对象。

</p>
<p>stub的真实力量是可以拥有spy的接口。记住被stub的接口集成了例如<code>restore</code>之类的方法，故可以恢复成为原本的方法。

</p>
<h2>Mocks</h2>
<p><a href="http://xunitpatterns.com/Mock%20Object.html">Mock对象</a>就像是stubs和spies的组合，并且内建了<em>预编码地验证行为</em>，也被成为<em>期望</em>。Mocks会在前期设置它们的期望（而不会像我们常见的断言一样在执行后判断是否符合期望）并且在接收到不被期望的调用时立即失败。最终<code>mock.verify()</code>的调用会验证所有的期望是否符合。

</p>
<h3>创建mocks</h3>
<p>你可以创建一个匿名函数的mock，例如：

</p>
<pre><code>&quot;test should call event handler&quot;: function () {
  var mock = sinon.mock();
  var myElement = document.getElementsByTagName(&quot;a&quot;)[0];

  dom.addEventListener(myElement, &quot;mouseover&quot;, mock);
  dom.fireEvent(myElement, &quot;mouseover&quot;);

  mock.verify();
}</code></pre>
<p>如果mock被调用了超过一次，这个测试会立马失败。当<code>verify()</code>被调用时，如果mock没有被调用过则会抛出一个exception。

</p>
<p>你也可以为一个对象上的方法创建mock，这就和spies和stubs一样。接口稍微有些不同，我们需要创建：一个mock对象和设置我们想要给于期望的方法。

</p>
<pre><code>var mock = sinon.mock(jQuery);
mock.expects(&quot;each&quot;).once().callsArgWith(1, {}).returns({});</code></pre>
<p>如上代码创建了<code>jQuery.each</code>方法的期望：只被调用一次，并且指示它向之前的stub一样运作。

</p>
<h3>控制mock的期望</h3>
<p>Sinon的mocks支持了spy和stub的接口，尽管spy的接口比起mocks的接口来说没那么有趣。通常前期你会使用如下的方法来设置期望。注意这些方法也会返回expectation，这样你可以使用链式调用，符合声明使得代码可读性更高。

</p>
<ul>
<li><code>execptation.atLeast(callCount)</code><br/>
确保mock的被调用次数达到指定的次数。</li>
<li><code>expectation.atMost(callCount)</code><br/>
确保mock的被调用次数不会超过指定的次数。</li>
<li><code>expectation.exactly(callCount)</code><br/>
指定mock被调用的次数。</li>
<li><code>expectation.never()</code><br/>
<code>exactly(0)</code>的快捷方法。</li>
<li><code>expectation.once()</code><br/>
<code>exactly(1)</code>的快捷方法。</li>
<li><code>expectation.twice()</code><br/>
<code>exactly(2)</code>的快捷方法。</li>
<li><code>expectation.thrice()</code><br/>
<code>exactly(3)</code>的快捷方法。<br/></li>
<li><code>expectation.withArgs(arg1, arg2, ...)</code><br/>
就像spy的<code>calledWith(arg1, arg2, ...)</code>方法一样，只不过是它是用作前期对期望的设置。</li>
<li><code>expectation.withExactArgs(arg1, arg2, ...)</code><br/>
就像spy的<code>calledWithExactly(arg1, arg2, ...)</code>方法一样，只不过是它是用作前期对期望的设置。</li>
<li><code>expectation.on(thisObj)</code><br/>
期望<code>this</code>值匹配指定的对象。</li>
</ul>
<p>另外，mocks也继承了<code>restore</code>方法来恢复原始的方法。然而，大多数情况下你不需要直接调用它，<code>verify</code>方法会在验证所有的期望之后恢复方法。

</p>
<p>下面是我在书中用到的一个例子。我构建了一个<a href="http://en.wikipedia.org/wiki/Comet_%28programming%29">comet客户端</a>用于长轮询从服务器端返回数据。下面的例子中期望在comet客户端在执行<code>connect</code>方法的时候，调用<code>ajax.poll</code>方法并传给指定的url。

</p>
<pre><code>&quot;test connect should start polling&quot;: function () {
  var client = Object.create(ajax.cometClient);
  client.url = &quot;/my/url&quot;;
  var mock = sinon.mock(ajax);
  mock.expects(&quot;poll&quot;).once().withArgs(&quot;/my/url&quot;).returns({});

  client.connect();

  mock.verify();
}</code></pre>
<p>你可能已经注意到<code>mock.verify</code>每次都在最后被调用，可以在测试框架中集成在最后默认执行会是一种不错的方式。我会展示在下一篇文章中展示Sinon在这个领域提供的东西。

</p>
<h2>现状</h2>
<p>目前，这篇文章中提到的东西都是可以工作的，经过了充份的测试并且可以使用。如果你想要尝试，你可以找到一份<a href="http://cjohansen.no/sinon/sinon.preview-20100525.js">preview version</a>。所有的代码在<a href="http://gitorious.org/sinon/">Gitorious</a>都可以找到。文档还很欠缺。还有更多特性可以被使用，它们会在下几篇文章中描述。最后，我正在写test/stub/mock timer和XMLHttpRequest的工具，但是它们还没有被完成。（译者言：翻译此文的时候这些都已经完成了，可以去<a href="http://sinonjs.org/">Sinon.JS</a>官网看下）</p>
</div>
</body>
</html>
